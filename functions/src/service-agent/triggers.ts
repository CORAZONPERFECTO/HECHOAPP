import * as functions from "firebase-functions";
import * as admin from "firebase-admin";

const db = admin.firestore();

// 1. Evidence Created -> Draft Quote
export const onEvidenceCreated = functions.firestore
    .document('orgs/{orgId}/tickets/{ticketId}/evidence/{evidenceId}')
    .onCreate(async (snap, context) => {
        const { orgId, ticketId } = context.params;
        const evidenceData = snap.data();

        console.log(`Evidence created for Ticket ${ticketId}:`, evidenceData.type);

        // A. Logic to determine if we should Auto-Draft
        // For now, if "DIAGNOSIS" evidence is uploaded, we trigger the "Draft Agent"
        const ticketRef = db.doc(`orgs/${orgId}/tickets/${ticketId}`);
        const ticketSnap = await ticketRef.get();
        const ticket = ticketSnap.data();

        if (ticket && (ticket.serviceStatus === 'DIAGNOSIS_IN_PROGRESS' || ticket.serviceStatus === 'ON_SITE')) {
            // Update Status to EVIDENCE_READY
            await ticketRef.update({
                serviceStatus: 'EVIDENCE_READY',
                updatedAt: admin.firestore.FieldValue.serverTimestamp()
            });

            // --- AI EXPRESS QUOTE GENERATION ---
            try {
                // Construct GCS URI (Preferred for Vertex AI)
                const bucketName = admin.storage().bucket().name;
                let gcsUri = "";

                if (evidenceData.storagePath) {
                    gcsUri = `gs://${bucketName}/${evidenceData.storagePath}`;
                } else if (evidenceData.url) {
                    console.warn("Evidence missing storagePath, skipping AI Draft");
                    return;
                }

                console.log(`Starting AI Analysis for ${gcsUri}...`);

                // Dynamic import to avoid cold start issues if not used? 
                // Actually top level import is fine but maybe safer here for tree shaking
                const { analyzeEvidenceAndDraftQuote } = await import('./ai-engine');
                const aiResult = await analyzeEvidenceAndDraftQuote(gcsUri, ticket);

                console.log("AI Result:", JSON.stringify(aiResult, null, 2));

                // Save Quote Draft
                const quoteData = {
                    ticketId,
                    items: aiResult.parts.map(p => ({
                        description: p.name,
                        unitPrice: p.estimatedNativePrice,
                        quantity: 1,
                        total: p.estimatedNativePrice
                    })),
                    laborCost: aiResult.laborCost,
                    totalCost: aiResult.recommendedTotal,
                    diagnosis: aiResult.diagnosis,
                    status: 'DRAFT',
                    aiConfidence: aiResult.confidence,
                    aiReasoning: aiResult.reasoning,
                    createdAt: admin.firestore.FieldValue.serverTimestamp()
                };

                const quoteRef = await db.collection(`orgs/${orgId}/quotes`).add(quoteData);

                // Update Ticket with Draft Info
                await ticketRef.update({
                    draftQuoteId: quoteRef.id,
                    serviceStatus: 'QUOTE_DRAFTED', // Advance state immediately if AI succeeds
                    description: ticket.description ? ticket.description + "\n[AI Diagnosis]: " + aiResult.diagnosis : "[AI Diagnosis]: " + aiResult.diagnosis
                });

                // Audit Log
                await db.collection(`orgs/${orgId}/auditLogs`).add({
                    ticketId,
                    action: 'AI_QOUTE_GENERATED',
                    actorId: 'VERTEX_AI',
                    details: `Quote draft generated by Gemini. Confidence: ${aiResult.confidence}`,
                    metadata: { quoteId: quoteRef.id, diagnosis: aiResult.diagnosis },
                    timestamp: admin.firestore.FieldValue.serverTimestamp()
                });

                await db.collection(`orgs/${orgId}/agentRuns`).add({
                    ticketId,
                    trigger: 'EVIDENCE_UPLOADED',
                    status: 'COMPLETED',
                    startedAt: admin.firestore.FieldValue.serverTimestamp(),
                    logs: [`AI Analysis complete. Quote ${quoteRef.id} drafted.`]
                });

            } catch (err) {
                console.error("AI Generation Failed:", err);
                await db.collection(`orgs/${orgId}/agentRuns`).add({
                    ticketId,
                    trigger: 'EVIDENCE_UPLOADED',
                    status: 'FAILED',
                    error: err instanceof Error ? err.message : 'Unknown AI Error',
                    startedAt: admin.firestore.FieldValue.serverTimestamp()
                });
            }
        }
    });

// 2. Approval Updated -> Send to Client (if Approved)
export const onApprovalUpdated = functions.firestore
    .document('orgs/{orgId}/tickets/{ticketId}/approvals/{approvalId}')
    .onUpdate(async (change, context) => {
        const newValue = change.after.data();
        const previousValue = change.before.data();

        // Check for transition to APPROVED
        if (newValue.status === 'APPROVED' && previousValue.status !== 'APPROVED') {
            const { orgId, ticketId } = context.params;
            console.log(`Approval ${context.params.approvalId} APPROVED. Generating PDF...`);

            // A. Generate PDF (Mock)
            // const pdfUrl = await generateQuotePDF(newValue.quoteId);
            const pdfUrl = "https://mock.com/quote.pdf"; // Mock

            // B. Update Ticket Status
            await db.doc(`orgs/${orgId}/tickets/${ticketId}`).update({
                serviceStatus: 'QUOTE_SENT',
                currentQuoteUrl: pdfUrl,
                updatedAt: admin.firestore.FieldValue.serverTimestamp()
            });

            // C. Send WhatsApp to Client
            // await sendWhatsAppMessage(ticket.clientPhone, "Su cotización está lista: " + pdfUrl);
            await db.collection(`orgs/${orgId}/agentRuns`).add({
                ticketId,
                trigger: 'APPROVAL_GRANTED',
                status: 'RUNNING',
                startedAt: admin.firestore.FieldValue.serverTimestamp(),
                logs: [`Approval granted. Sending Quote PDF to client.`]
            });

            // Audit
            await db.collection(`orgs/${orgId}/auditLogs`).add({
                ticketId,
                action: 'QUOTE_APPROVED',
                actorId: 'ADMIN', // Or context auth user if available
                details: `Quote approved in ${context.params.approvalId}`,
                timestamp: admin.firestore.FieldValue.serverTimestamp()
            });

        }
    });

// 3. Payment Created -> PENDING_REVIEW
export const onPaymentCreated = functions.firestore
    .document('orgs/{orgId}/payments/{paymentId}')
    .onCreate(async (snap, context) => {
        const payment = snap.data();
        const { orgId } = context.params;

        // Assuming payment doc has ticketId reference or invoiceId
        // Let's assume ticketId is present for simplified correlation
        if (payment.ticketId) {
            console.log(`Payment created for Ticket ${payment.ticketId}`);

            // Update Ticket Status to PROOF_RECEIVED
            await db.doc(`orgs/${orgId}/tickets/${payment.ticketId}`).update({
                serviceStatus: 'PROOF_RECEIVED',
                updatedAt: admin.firestore.FieldValue.serverTimestamp()
            });

            // Trigger Verification Agent (e.g. OCR)
            await db.collection(`orgs/${orgId}/agentRuns`).add({
                ticketId: payment.ticketId,
                trigger: 'PAYMENT_UPLOADED',
                status: 'RUNNING',
                startedAt: admin.firestore.FieldValue.serverTimestamp(),
                logs: [`Payment ${snap.id} uploaded. Starting verification.`]
            });

            // Audit
            await db.collection(`orgs/${orgId}/auditLogs`).add({
                ticketId: payment.ticketId,
                action: 'PAYMENT_RECEIVED',
                actorId: 'CLIENT',
                details: `Payment uploaded: ${snap.id}`,
                timestamp: admin.firestore.FieldValue.serverTimestamp()
            });
        }
    });
